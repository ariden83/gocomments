package comments

import (
	"bufio"
	"errors"
	"os"
	"path/filepath"
	"regexp"

	yaml "gopkg.in/yaml.v3"
)

// CommentConfig is the configuration to sort all comments.
type CommentConfig struct {
	// Local is the root Go module name. All subpackages of this module
	// will be separated from the external packages.
	Local string `yaml:"local"`

	// Prefixes is a list of relative Go packages from the root package.
	// All comments with these prefixes will be separated from each other.
	Prefixes []string `yaml:"prefixes"`

	// Signature is the personal signature affixed at the end of the comment in order to allow users and
	// other iterations to find the autogenerated comments and to be able to evolve
	// them with future updates of the script.
	// If empty, the automatically added prefix is "auto".
	Signature *string `yaml:"signature"`
	// Allows you to know if you update the tagged comments each time the script is executed.
	UpdateComments bool            `yaml:"update-comments"`
	ActiveExamples bool            `yaml:"active-examples"`
	LocalAI        LocalAIConfig   `yaml:"localai"`
	OpenAI         OpenAIConfig    `yaml:"openai"`
	Anthropic      AnthropicConfig `yaml:"anthropic"`
}

// Merge merges the given CommentConfig with this configure and return
// a new CommentConfig with the merged result.
// - Local attribute value is overriden.
// - Prefixes attribute values are appended.
func (cfg *CommentConfig) Merge(newCfg *CommentConfig) *CommentConfig {
	if newCfg.Local != "" {
		cfg.Local = newCfg.Local
	}
	if newCfg.Signature != nil {
		cfg.Signature = newCfg.Signature
	}

	{
		cfg.LocalAI.URL = "http://tokenizer_container:5000"
		cfg.LocalAI.APIModelVersion = 10
		if newCfg.LocalAI.Active != nil {
			cfg.LocalAI.Active = newCfg.LocalAI.Active
		}
		if newCfg.LocalAI.APIModelVersion != 0 {
			cfg.LocalAI.APIModelVersion = newCfg.LocalAI.APIModelVersion
		}
		if newCfg.LocalAI.URL != "" {
			cfg.LocalAI.URL = newCfg.LocalAI.URL
		}
	}

	{
		if newCfg.OpenAI.Active != nil {
			cfg.OpenAI.Active = newCfg.OpenAI.Active
		}
		if newCfg.OpenAI.APIKey != nil {
			cfg.OpenAI.APIKey = newCfg.OpenAI.APIKey
		}
		if newCfg.OpenAI.URL != "" {
			cfg.OpenAI.URL = newCfg.OpenAI.URL
		}
	}

	{
		if newCfg.Anthropic.Active != nil {
			cfg.Anthropic.Active = newCfg.Anthropic.Active
		}
		if newCfg.Anthropic.URL != "" {
			cfg.Anthropic.URL = newCfg.Anthropic.URL
		}
	}
	return cfg
}

// CommentConfigCache is a cache to contains the configuration for all processed files.
type CommentConfigCache struct {
	rootConfig CommentConfig
	configs    map[string]*CommentConfig
}

// NewConfigCache instantiates a new cache to store the configuration for all processed files.
func NewConfigCache(local string, prefixes []string) *CommentConfigCache {
	return &CommentConfigCache{
		rootConfig: CommentConfig{
			Local:    local,
			Prefixes: prefixes,
		},
		configs: make(map[string]*CommentConfig),
	}
}

// Get returns the configuration for the given processed file.
// Keep all intermediate configurations in the cache.
func (cache *CommentConfigCache) Get(filename string) (*CommentConfig, error) {
	absFilepath, _ := filepath.Abs(filename)
	dirPath := filepath.Dir(absFilepath)

	cfg, err := cache.get(dirPath)
	if err != nil {
		return nil, err
	}

	return cfg, nil
}

func (cache *CommentConfigCache) get(dirPath string) (*CommentConfig, error) {
	cfg, ok := cache.configs[dirPath]
	if ok {
		if cfg == nil {
			panic("cfg should not be nil")
		}
		return cfg, nil
	}

	var parentCfg *CommentConfig

	goModFilepath := filepath.Join(dirPath, "go.mod")
	modname, goModFileExists, err := getModuleNameFromGoModFile(goModFilepath)
	if err != nil {
		return nil, err
	}

	if !goModFileExists && dirPath != "." && dirPath != "/" {
		parentCfg, err = cache.get(filepath.Dir(dirPath))
		if err != nil {
			return nil, err
		}
	} else {
		parentCfg = &cache.rootConfig
		if parentCfg.Local == "" {
			parentCfg.Local = modname
		}
	}

	localCfg, err := readConfigFile(filepath.Join(dirPath, ".gocomments"))
	if err != nil {
		return nil, err
	}

	cfg = parentCfg
	if localCfg != nil {
		cfg = cfg.Merge(localCfg)
	}

	if cfg == nil {
		panic("cfg should not be nil")
	}

	cache.configs[dirPath] = cfg

	return cfg, nil
}

func readConfigFile(filename string) (*CommentConfig, error) {
	f, err := os.Open(filename)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return nil, nil
		}

		return nil, err
	}

	defer func() {
		_ = f.Close()
	}()

	var cfg CommentConfig
	if err := yaml.NewDecoder(f).Decode(&cfg); err != nil {
		return nil, err
	}

	return &cfg, nil
}

var goModModuleRegexp = regexp.MustCompile(`^module\s+(\S+)$`)

func getModuleNameFromGoModFile(goModFilepath string) (string, bool, error) {
	var modname string

	f, err := os.Open(goModFilepath)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return "", false, nil
		}

		return "", false, err
	}

	defer func() {
		_ = f.Close()
	}()

	s := bufio.NewScanner(f)
	for s.Scan() {
		line := s.Text()
		if m := goModModuleRegexp.FindStringSubmatch(line); m != nil {
			modname = m[1]
			break
		}
	}

	if err := s.Err(); err != nil {
		return "", true, err
	}

	return modname, true, nil
}
